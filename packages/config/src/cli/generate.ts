import fs from 'fs'
import path from 'path'

export interface GenerateOptions {
  /**
   * Path to the .env file to read
   */
  envPath: string

  /**
   * Path to write the generated TypeScript declaration file
   */
  outputPath: string
}

/**
 * Parse a .env file and extract all key names.
 * Strips VITE_ prefix to normalize to canonical names.
 */
export function parseEnvFile(content: string): string[] {
  const keys: string[] = []

  for (const line of content.split('\n')) {
    const trimmed = line.trim()

    // Skip empty lines and comments
    if (!trimmed || trimmed.startsWith('#')) {
      continue
    }

    // Extract key name (everything before the first =)
    const equalsIndex = trimmed.indexOf('=')
    if (equalsIndex === -1) {
      continue
    }

    let key = trimmed.substring(0, equalsIndex).trim()

    // Strip VITE_ prefix to normalize to canonical names
    if (key.startsWith('VITE_')) {
      key = key.substring(5)
    }

    // Only add unique keys
    if (key && !keys.includes(key)) {
      keys.push(key)
    }
  }

  return keys.sort()
}

/**
 * Generate TypeScript declaration content from a list of config keys.
 */
export function generateDeclaration(keys: string[], sourceFile: string): string {
  const keyDefinitions = keys.map(k => `    ${k}: string`).join('\n')

  return `// Auto-generated by @idealyst/config - DO NOT EDIT
// Generated from: ${sourceFile}
// Run \`idealyst-config generate\` to regenerate

declare module '@idealyst/config' {
  interface ConfigKeys {
${keyDefinitions}
  }

  interface IConfig {
    get<K extends keyof ConfigKeys>(key: K): string | undefined
    get<K extends keyof ConfigKeys>(key: K, defaultValue: string): string
    getRequired<K extends keyof ConfigKeys>(key: K): string
    has<K extends keyof ConfigKeys>(key: K): boolean
    validate(requiredKeys: (keyof ConfigKeys)[]): void
  }
}

export {}
`
}

/**
 * Generate TypeScript config types from an .env file.
 *
 * @param options - Generation options
 * @returns The path to the generated file
 */
export function generateConfigTypes(options: GenerateOptions): string {
  // Read the .env file
  if (!fs.existsSync(options.envPath)) {
    throw new Error(`Environment file not found: ${options.envPath}`)
  }

  const envContent = fs.readFileSync(options.envPath, 'utf-8')
  const keys = parseEnvFile(envContent)

  if (keys.length === 0) {
    console.warn('Warning: No environment variables found in', options.envPath)
  }

  // Generate the declaration content
  const declaration = generateDeclaration(keys, path.basename(options.envPath))

  // Ensure the output directory exists
  const outputDir = path.dirname(options.outputPath)
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true })
  }

  // Write the declaration file
  fs.writeFileSync(options.outputPath, declaration)

  return options.outputPath
}

/**
 * Find the most appropriate .env file in a directory.
 * Prefers .env.local > .env.development > .env
 */
export function findEnvFile(directory: string): string | null {
  const candidates = ['.env.local', '.env.development', '.env']

  for (const candidate of candidates) {
    const envPath = path.join(directory, candidate)
    if (fs.existsSync(envPath)) {
      return envPath
    }
  }

  return null
}
