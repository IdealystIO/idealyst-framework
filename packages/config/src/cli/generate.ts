import fs from 'fs'
import path from 'path'

export interface GenerateOptions {
  /**
   * Path to the platform-specific .env file (highest priority)
   */
  envPath?: string

  /**
   * Paths to inherited .env files (lowest to highest priority)
   * e.g., ['../shared/.env'] - shared is loaded first, then envPath overrides
   */
  inheritFrom?: string[]

  /**
   * Path to write the generated TypeScript config file
   */
  outputPath: string

  /**
   * Whether to generate types only (declaration file) or full config module
   */
  typesOnly?: boolean
}

/**
 * Parse a .env file and extract key-value pairs.
 * Strips VITE_ prefix to normalize to canonical names.
 */
export function parseEnvFile(filePath: string): Record<string, string> {
  if (!fs.existsSync(filePath)) {
    return {}
  }

  const content = fs.readFileSync(filePath, 'utf-8')
  const config: Record<string, string> = {}

  for (const line of content.split('\n')) {
    const trimmed = line.trim()

    // Skip empty lines and comments
    if (!trimmed || trimmed.startsWith('#')) {
      continue
    }

    // Extract key=value
    const equalsIndex = trimmed.indexOf('=')
    if (equalsIndex === -1) {
      continue
    }

    let key = trimmed.substring(0, equalsIndex).trim()
    let value = trimmed.substring(equalsIndex + 1).trim()

    // Remove quotes if present
    if ((value.startsWith('"') && value.endsWith('"')) ||
        (value.startsWith("'") && value.endsWith("'"))) {
      value = value.slice(1, -1)
    }

    // Strip VITE_ prefix to normalize to canonical names
    if (key.startsWith('VITE_')) {
      key = key.substring(5)
    }

    config[key] = value
  }

  return config
}

/**
 * Merge multiple env configs with later configs taking priority.
 */
export function mergeEnvConfigs(...configs: Record<string, string>[]): Record<string, string> {
  return Object.assign({}, ...configs)
}

/**
 * Generate TypeScript declaration content from config keys.
 */
export function generateDeclaration(keys: string[], sourceFiles: string[]): string {
  const keyDefinitions = keys.map(k => `    ${k}: string`).join('\n')
  const sources = sourceFiles.join(', ')

  return `// Auto-generated by @idealyst/config - DO NOT EDIT
// Sources: ${sources}
// Run \`idealyst-config generate\` to regenerate

declare module '@idealyst/config' {
  interface ConfigKeys {
${keyDefinitions}
  }

  interface IConfig {
    get<K extends keyof ConfigKeys>(key: K): string | undefined
    get<K extends keyof ConfigKeys>(key: K, defaultValue: string): string
    getRequired<K extends keyof ConfigKeys>(key: K): string
    has<K extends keyof ConfigKeys>(key: K): boolean
    validate(requiredKeys: (keyof ConfigKeys)[]): void
  }
}

export {}
`
}

/**
 * Generate a TypeScript config module with actual values.
 */
export function generateConfigModule(config: Record<string, string>, sourceFiles: string[]): string {
  const sources = sourceFiles.join(', ')
  const entries = Object.entries(config)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([key, value]) => `  ${key}: ${JSON.stringify(value)}`)
    .join(',\n')

  return `// Auto-generated by @idealyst/config - DO NOT EDIT
// Sources: ${sources}
// Run \`idealyst-config generate\` to regenerate

/**
 * Generated configuration values.
 * Merged from: ${sources}
 */
export const generatedConfig: Record<string, string> = {
${entries}
}
`
}

/**
 * Generate config from .env files with inheritance support.
 */
export function generateConfigTypes(options: GenerateOptions): { outputPath: string; keys: string[] } {
  const sourceFiles: string[] = []
  const configs: Record<string, string>[] = []

  // Load inherited configs first (lowest priority)
  if (options.inheritFrom) {
    for (const inheritPath of options.inheritFrom) {
      const resolvedPath = path.isAbsolute(inheritPath)
        ? inheritPath
        : path.resolve(path.dirname(options.outputPath), inheritPath)

      if (fs.existsSync(resolvedPath)) {
        configs.push(parseEnvFile(resolvedPath))
        sourceFiles.push(path.basename(resolvedPath))
      }
    }
  }

  // Load main env file (highest priority)
  if (options.envPath) {
    const resolvedEnvPath = path.isAbsolute(options.envPath)
      ? options.envPath
      : path.resolve(process.cwd(), options.envPath)

    if (fs.existsSync(resolvedEnvPath)) {
      configs.push(parseEnvFile(resolvedEnvPath))
      sourceFiles.push(path.basename(resolvedEnvPath))
    }
  }

  // Merge configs
  const mergedConfig = mergeEnvConfigs(...configs)
  const keys = Object.keys(mergedConfig).sort()

  if (keys.length === 0) {
    console.warn('Warning: No environment variables found')
  }

  // Ensure output directory exists
  const outputDir = path.dirname(options.outputPath)
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true })
  }

  if (options.typesOnly) {
    // Generate declaration file only
    const declaration = generateDeclaration(keys, sourceFiles)
    fs.writeFileSync(options.outputPath, declaration)
  } else {
    // Generate full config module
    const module = generateConfigModule(mergedConfig, sourceFiles)
    fs.writeFileSync(options.outputPath, module)

    // Also generate declaration file alongside
    const declPath = options.outputPath.replace(/\.ts$/, '.d.ts')
    if (declPath !== options.outputPath) {
      const declaration = generateDeclaration(keys, sourceFiles)
      fs.writeFileSync(declPath, declaration)
    }
  }

  return { outputPath: options.outputPath, keys }
}

/**
 * Find the most appropriate .env file in a directory.
 */
export function findEnvFile(directory: string): string | null {
  const candidates = ['.env.local', '.env.development', '.env']

  for (const candidate of candidates) {
    const envPath = path.join(directory, candidate)
    if (fs.existsSync(envPath)) {
      return envPath
    }
  }

  return null
}

/**
 * Look for a shared .env file in parent directories.
 */
export function findSharedEnv(directory: string): string | null {
  // Common patterns for shared env in monorepos
  const patterns = [
    '../shared/.env',
    '../../shared/.env',
    '../.env.shared',
    '../../.env.shared',
  ]

  for (const pattern of patterns) {
    const sharedPath = path.resolve(directory, pattern)
    if (fs.existsSync(sharedPath)) {
      return sharedPath
    }
  }

  return null
}
