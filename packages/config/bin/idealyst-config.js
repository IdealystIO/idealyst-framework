#!/usr/bin/env node

/**
 * CLI for @idealyst/config - Generate TypeScript types from .env files
 *
 * This is a self-contained JavaScript CLI that doesn't require TypeScript
 * compilation at runtime. It implements the same logic as src/cli/generate.ts.
 */

const fs = require('fs')
const path = require('path')

/**
 * Parse a .env file and extract all key names.
 * Strips VITE_ prefix to normalize to canonical names.
 */
function parseEnvFile(content) {
  const keys = []

  for (const line of content.split('\n')) {
    const trimmed = line.trim()

    // Skip empty lines and comments
    if (!trimmed || trimmed.startsWith('#')) {
      continue
    }

    // Extract key name (everything before the first =)
    const equalsIndex = trimmed.indexOf('=')
    if (equalsIndex === -1) {
      continue
    }

    let key = trimmed.substring(0, equalsIndex).trim()

    // Strip VITE_ prefix to normalize to canonical names
    if (key.startsWith('VITE_')) {
      key = key.substring(5)
    }

    // Only add unique keys
    if (key && !keys.includes(key)) {
      keys.push(key)
    }
  }

  return keys.sort()
}

/**
 * Generate TypeScript declaration content from a list of config keys.
 */
function generateDeclaration(keys, sourceFile) {
  const keyDefinitions = keys.map(k => `    ${k}: string`).join('\n')

  return `// Auto-generated by @idealyst/config - DO NOT EDIT
// Generated from: ${sourceFile}
// Run \`idealyst-config generate\` to regenerate

declare module '@idealyst/config' {
  interface ConfigKeys {
${keyDefinitions}
  }

  interface IConfig {
    get<K extends keyof ConfigKeys>(key: K): string | undefined
    get<K extends keyof ConfigKeys>(key: K, defaultValue: string): string
    getRequired<K extends keyof ConfigKeys>(key: K): string
    has<K extends keyof ConfigKeys>(key: K): boolean
    validate(requiredKeys: (keyof ConfigKeys)[]): void
  }
}

export {}
`
}

/**
 * Find the most appropriate .env file in a directory.
 */
function findEnvFile(directory) {
  const candidates = ['.env.local', '.env.development', '.env']

  for (const candidate of candidates) {
    const envPath = path.join(directory, candidate)
    if (fs.existsSync(envPath)) {
      return envPath
    }
  }

  return null
}

function printUsage() {
  console.log(`
@idealyst/config - Generate TypeScript types from .env files

Usage:
  idealyst-config generate [options]

Options:
  --env <path>      Path to .env file (default: auto-detect)
  --output <path>   Output path for .d.ts file (default: src/env.d.ts)
  --help            Show this help message

Examples:
  idealyst-config generate
  idealyst-config generate --env .env.local
  idealyst-config generate --env .env --output types/env.d.ts
`)
}

function parseArgs(args) {
  const result = {}

  for (let i = 0; i < args.length; i++) {
    const arg = args[i]

    if (arg === '--help' || arg === '-h') {
      result.help = true
    } else if (arg === '--env' && args[i + 1]) {
      result.env = args[++i]
    } else if (arg === '--output' && args[i + 1]) {
      result.output = args[++i]
    } else if (!arg.startsWith('-') && !result.command) {
      result.command = arg
    }
  }

  return result
}

function main() {
  const args = parseArgs(process.argv.slice(2))

  if (args.help || (!args.command && process.argv.length <= 2)) {
    printUsage()
    process.exit(0)
  }

  if (args.command !== 'generate') {
    console.error(`Unknown command: ${args.command}`)
    console.error('Run "idealyst-config --help" for usage information.')
    process.exit(1)
  }

  const cwd = process.cwd()

  // Find or use the specified .env file
  let envPath
  if (args.env) {
    envPath = path.isAbsolute(args.env) ? args.env : path.join(cwd, args.env)
  } else {
    envPath = findEnvFile(cwd)
    if (!envPath) {
      console.error('Error: No .env file found in current directory.')
      console.error('Create a .env file or specify one with --env <path>')
      process.exit(1)
    }
  }

  // Check if env file exists
  if (!fs.existsSync(envPath)) {
    console.error(`Error: Environment file not found: ${envPath}`)
    process.exit(1)
  }

  // Determine output path
  const outputPath = args.output
    ? (path.isAbsolute(args.output) ? args.output : path.join(cwd, args.output))
    : path.join(cwd, 'src', 'env.d.ts')

  try {
    // Read and parse env file
    const envContent = fs.readFileSync(envPath, 'utf-8')
    const keys = parseEnvFile(envContent)

    if (keys.length === 0) {
      console.warn('Warning: No environment variables found in', envPath)
    }

    // Generate declaration
    const declaration = generateDeclaration(keys, path.basename(envPath))

    // Ensure output directory exists
    const outputDir = path.dirname(outputPath)
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true })
    }

    // Write declaration file
    fs.writeFileSync(outputPath, declaration)

    console.log(`Generated config types at: ${outputPath}`)
    console.log(`Source: ${envPath}`)
    console.log(`Keys: ${keys.join(', ')}`)
  } catch (error) {
    console.error('Error generating config types:', error.message)
    process.exit(1)
  }
}

main()
