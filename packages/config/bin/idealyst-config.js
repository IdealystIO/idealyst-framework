#!/usr/bin/env node

/**
 * CLI for @idealyst/config - Generate config from .env files with inheritance
 *
 * Supports monorepo patterns with shared config:
 *   shared/.env      → base config (lowest priority)
 *   web/.env         → web overrides
 *   mobile/.env      → mobile overrides
 */

const fs = require('fs')
const path = require('path')

/**
 * Parse a .env file and extract key-value pairs.
 */
function parseEnvFile(filePath) {
  if (!fs.existsSync(filePath)) {
    return {}
  }

  const content = fs.readFileSync(filePath, 'utf-8')
  const config = {}

  for (const line of content.split('\n')) {
    const trimmed = line.trim()

    if (!trimmed || trimmed.startsWith('#')) {
      continue
    }

    const equalsIndex = trimmed.indexOf('=')
    if (equalsIndex === -1) {
      continue
    }

    let key = trimmed.substring(0, equalsIndex).trim()
    let value = trimmed.substring(equalsIndex + 1).trim()

    // Remove quotes if present
    if ((value.startsWith('"') && value.endsWith('"')) ||
        (value.startsWith("'") && value.endsWith("'"))) {
      value = value.slice(1, -1)
    }

    // Strip VITE_ prefix to normalize
    if (key.startsWith('VITE_')) {
      key = key.substring(5)
    }

    config[key] = value
  }

  return config
}

/**
 * Generate TypeScript config module with actual values.
 */
function generateConfigModule(config, sourceFiles) {
  const sources = sourceFiles.join(', ')
  const entries = Object.entries(config)
    .sort(([a], [b]) => a.localeCompare(b))
    .map(([key, value]) => `  ${key}: ${JSON.stringify(value)}`)
    .join(',\n')

  return `// Auto-generated by @idealyst/config - DO NOT EDIT
// Sources: ${sources}
// Run \`idealyst-config generate\` to regenerate

/**
 * Generated configuration values.
 * Merged from: ${sources}
 */
export const generatedConfig: Record<string, string> = {
${entries}
}
`
}

/**
 * Generate TypeScript declaration file.
 */
function generateDeclaration(keys, sourceFiles) {
  const keyDefinitions = keys.map(k => `    ${k}: string`).join('\n')
  const sources = sourceFiles.join(', ')

  return `// Auto-generated by @idealyst/config - DO NOT EDIT
// Sources: ${sources}
// Run \`idealyst-config generate\` to regenerate

declare module '@idealyst/config' {
  interface ConfigKeys {
${keyDefinitions}
  }

  interface IConfig {
    get<K extends keyof ConfigKeys>(key: K): string | undefined
    get<K extends keyof ConfigKeys>(key: K, defaultValue: string): string
    getRequired<K extends keyof ConfigKeys>(key: K): string
    has<K extends keyof ConfigKeys>(key: K): boolean
    validate(requiredKeys: (keyof ConfigKeys)[]): void
  }
}

export {}
`
}

/**
 * Find .env file in directory.
 */
function findEnvFile(directory) {
  const candidates = ['.env.local', '.env.development', '.env']
  for (const candidate of candidates) {
    const envPath = path.join(directory, candidate)
    if (fs.existsSync(envPath)) {
      return envPath
    }
  }
  return null
}

/**
 * Look for shared .env in common monorepo locations.
 */
function findSharedEnv(directory) {
  const patterns = [
    '../shared/.env',
    '../../shared/.env',
    '../../packages/shared/.env',
    '../.env.shared',
  ]
  for (const pattern of patterns) {
    const sharedPath = path.resolve(directory, pattern)
    if (fs.existsSync(sharedPath)) {
      return sharedPath
    }
  }
  return null
}

function printUsage() {
  console.log(`
@idealyst/config - Generate config from .env files with inheritance

Usage:
  idealyst-config generate [options]

Options:
  --env <path>        Path to .env file (default: auto-detect)
  --extends <path>    Inherit from another .env file (can use multiple times)
  --output <path>     Output path for generated config (default: src/config.generated.ts)
  --types-only        Generate only .d.ts file, no values
  --help              Show this help message

Examples:
  # Simple usage - auto-detect .env
  idealyst-config generate

  # With shared config inheritance
  idealyst-config generate --extends ../shared/.env --env .env

  # Multiple inheritance (lowest to highest priority)
  idealyst-config generate --extends ../../shared/.env --extends ../.env.common --env .env

  # Types only (for type checking without exposing values)
  idealyst-config generate --types-only --output src/env.d.ts

Inheritance:
  In a monorepo with shared/web/mobile packages, you can set up inheritance:

  shared/.env     → API_URL=https://api.example.com
  web/.env        → API_URL=https://web-api.example.com (overrides shared)
  mobile/.env     → (inherits API_URL from shared)

  The --extends flag loads configs in order, with later files taking priority.
`)
}

function parseArgs(args) {
  const result = { extends: [] }

  for (let i = 0; i < args.length; i++) {
    const arg = args[i]

    if (arg === '--help' || arg === '-h') {
      result.help = true
    } else if (arg === '--env' && args[i + 1]) {
      result.env = args[++i]
    } else if (arg === '--extends' && args[i + 1]) {
      result.extends.push(args[++i])
    } else if (arg === '--output' && args[i + 1]) {
      result.output = args[++i]
    } else if (arg === '--types-only') {
      result.typesOnly = true
    } else if (!arg.startsWith('-') && !result.command) {
      result.command = arg
    }
  }

  return result
}

function main() {
  const args = parseArgs(process.argv.slice(2))

  if (args.help || (!args.command && process.argv.length <= 2)) {
    printUsage()
    process.exit(0)
  }

  if (args.command !== 'generate') {
    console.error(`Unknown command: ${args.command}`)
    console.error('Run "idealyst-config --help" for usage information.')
    process.exit(1)
  }

  const cwd = process.cwd()
  const sourceFiles = []
  const configs = []

  // Load inherited configs first (lowest priority)
  for (const extendPath of args.extends) {
    const resolvedPath = path.isAbsolute(extendPath)
      ? extendPath
      : path.resolve(cwd, extendPath)

    if (fs.existsSync(resolvedPath)) {
      configs.push(parseEnvFile(resolvedPath))
      sourceFiles.push(path.relative(cwd, resolvedPath))
      console.log(`  ← ${path.relative(cwd, resolvedPath)}`)
    } else {
      console.warn(`Warning: Inherited env file not found: ${resolvedPath}`)
    }
  }

  // Auto-detect shared env if no extends specified
  if (args.extends.length === 0) {
    const sharedEnv = findSharedEnv(cwd)
    if (sharedEnv) {
      configs.push(parseEnvFile(sharedEnv))
      sourceFiles.push(path.relative(cwd, sharedEnv))
      console.log(`  ← ${path.relative(cwd, sharedEnv)} (auto-detected shared)`)
    }
  }

  // Load main env file (highest priority)
  let envPath
  if (args.env) {
    envPath = path.isAbsolute(args.env) ? args.env : path.resolve(cwd, args.env)
  } else {
    envPath = findEnvFile(cwd)
  }

  if (envPath && fs.existsSync(envPath)) {
    configs.push(parseEnvFile(envPath))
    sourceFiles.push(path.relative(cwd, envPath))
    console.log(`  ← ${path.relative(cwd, envPath)}`)
  } else if (args.env) {
    console.error(`Error: Environment file not found: ${args.env}`)
    process.exit(1)
  }

  if (configs.length === 0) {
    console.error('Error: No .env files found.')
    console.error('Create a .env file or specify one with --env <path>')
    process.exit(1)
  }

  // Merge configs (later configs override earlier ones)
  const mergedConfig = Object.assign({}, ...configs)
  const keys = Object.keys(mergedConfig).sort()

  // Determine output path
  const outputPath = args.output
    ? (path.isAbsolute(args.output) ? args.output : path.resolve(cwd, args.output))
    : path.resolve(cwd, 'src', 'config.generated.ts')

  // Ensure output directory exists
  const outputDir = path.dirname(outputPath)
  if (!fs.existsSync(outputDir)) {
    fs.mkdirSync(outputDir, { recursive: true })
  }

  if (args.typesOnly) {
    // Generate declaration file only
    const declaration = generateDeclaration(keys, sourceFiles)
    fs.writeFileSync(outputPath, declaration)
    console.log(`\nGenerated types at: ${path.relative(cwd, outputPath)}`)
  } else {
    // Generate config module
    const module = generateConfigModule(mergedConfig, sourceFiles)
    fs.writeFileSync(outputPath, module)
    console.log(`\nGenerated config at: ${path.relative(cwd, outputPath)}`)

    // Also generate declaration file
    const declPath = outputPath.replace(/\.ts$/, '.d.ts')
    const declaration = generateDeclaration(keys, sourceFiles)
    fs.writeFileSync(declPath, declaration)
    console.log(`Generated types at: ${path.relative(cwd, declPath)}`)
  }

  console.log(`Keys: ${keys.join(', ')}`)
}

main()
