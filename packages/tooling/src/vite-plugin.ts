/**
 * Idealyst Docs Vite Plugin
 *
 * Generates a component registry at build time by analyzing TypeScript source.
 * Replaces placeholder exports from @idealyst/tooling with actual generated values.
 *
 * Usage:
 * ```ts
 * // vite.config.ts
 * import { idealystDocsPlugin } from '@idealyst/tooling';
 *
 * export default defineConfig({
 *   plugins: [
 *     idealystDocsPlugin({
 *       componentPaths: ['../../packages/components/src'],
 *       themePath: '../../packages/theme/src/lightTheme.ts',
 *     }),
 *   ],
 * });
 * ```
 *
 * Then in your app:
 * ```ts
 * import { componentRegistry, componentNames, getComponentsByCategory } from '@idealyst/tooling';
 * ```
 */

import type { Plugin, ViteDevServer } from 'vite';
import * as fs from 'fs';
import * as path from 'path';
import { analyzeComponents } from './analyzer';
import type { IdealystDocsPluginOptions, ComponentRegistry } from './analyzer/types';

/**
 * Create the Idealyst Docs Vite plugin.
 */
export function idealystDocsPlugin(options: IdealystDocsPluginOptions): Plugin {
  let registry: ComponentRegistry | null = null;
  let server: ViteDevServer | null = null;

  const { debug = false, output, outputPath } = options;

  const log = (...args: any[]) => {
    if (debug) console.log('[idealyst-docs]', ...args);
  };

  /**
   * Generate the registry by analyzing components.
   */
  function generateRegistry(): ComponentRegistry {
    log('Generating component registry...');
    log('Component paths:', options.componentPaths);
    log('Theme path:', options.themePath);

    try {
      registry = analyzeComponents(options);
      log(`Generated registry with ${Object.keys(registry).length} components`);
      if (debug) {
        log('Components found:', Object.keys(registry));
      }

      // Optionally write to file
      if (output === 'file' && outputPath) {
        const outputDir = path.dirname(outputPath);
        if (!fs.existsSync(outputDir)) {
          fs.mkdirSync(outputDir, { recursive: true });
        }
        fs.writeFileSync(
          outputPath,
          `// Auto-generated by @idealyst/tooling - DO NOT EDIT\n` +
          `export const componentRegistry = ${JSON.stringify(registry, null, 2)} as const;\n`
        );
        log(`Wrote registry to ${outputPath}`);
      }

      return registry;
    } catch (error) {
      console.error('[idealyst-docs] Error generating registry:', error);
      return {};
    }
  }

  return {
    name: 'idealyst-docs',

    configureServer(_server) {
      server = _server;
    },

    // Transform @idealyst/tooling to inject the actual registry
    transform(code, id) {
      // Check if this is the tooling package's index file
      const isToolingIndex = id.includes('@idealyst/tooling') && id.endsWith('index.ts');
      const isToolingSrc = id.includes('/packages/tooling/src/index.ts');

      if (isToolingIndex || isToolingSrc) {
        console.log(`[idealyst-docs] Transforming tooling index: ${id}`);

        if (!registry) {
          registry = generateRegistry();
        }

        // Replace the placeholder exports with actual values
        let transformed = code;

        // Replace: export const componentRegistry = {};
        // Note: TypeScript types are stripped before transform, so we match JS not TS
        transformed = transformed.replace(
          /export const componentRegistry\s*=\s*\{\s*\};?/,
          `export const componentRegistry = ${JSON.stringify(registry, null, 2)};`
        );

        log(`Code transformed: ${code !== transformed}`);

        // Replace: export const componentNames = [];
        // Note: TypeScript types are stripped before transform
        transformed = transformed.replace(
          /export const componentNames\s*=\s*\[\s*\];?/,
          `export const componentNames = ${JSON.stringify(Object.keys(registry))};`
        );

        // Replace getComponentsByCategory with actual implementation that uses the real registry
        // Match JS version (no type annotations)
        transformed = transformed.replace(
          /export function getComponentsByCategory\(category\)\s*\{[\s\S]*?^\}/m,
          `export function getComponentsByCategory(category) {
  return Object.entries(componentRegistry)
    .filter(([_, def]) => def.category === category)
    .map(([name]) => name);
}`
        );

        // Replace getPropConfig with actual implementation
        // Match JS version (no type annotations)
        transformed = transformed.replace(
          /export function getPropConfig\(componentName\)\s*\{[\s\S]*?^\}/m,
          `export function getPropConfig(componentName) {
  const def = componentRegistry[componentName];
  if (!def) return {};
  return Object.entries(def.props).reduce((acc, [key, prop]) => {
    if (prop.values && prop.values.length > 0) {
      acc[key] = { type: 'select', options: prop.values, default: prop.default };
    } else if (prop.type === 'boolean') {
      acc[key] = { type: 'boolean', default: prop.default ?? false };
    } else if (prop.type === 'string') {
      acc[key] = { type: 'text', default: prop.default ?? '' };
    } else if (prop.type === 'number') {
      acc[key] = { type: 'number', default: prop.default ?? 0 };
    }
    return acc;
  }, {});
}`
        );

        return {
          code: transformed,
          map: null,
        };
      }

      return null;
    },

    // Regenerate on component file changes
    handleHotUpdate({ file, server }) {
      // Check if the changed file is a component file
      const isComponentFile =
        options.componentPaths.some(p => file.includes(path.resolve(p))) &&
        (file.endsWith('.ts') || file.endsWith('.tsx'));

      // Check if the changed file is the theme file
      const isThemeFile = file.includes(path.resolve(options.themePath));

      if (isComponentFile || isThemeFile) {
        log(`File changed: ${file}, regenerating registry...`);

        // Clear cached registry
        registry = null;

        // Invalidate the tooling module to trigger re-transform
        const toolingMods = Array.from(server.moduleGraph.idToModuleMap.values())
          .filter(m => m.id && (m.id.includes('@idealyst/tooling') || m.id.includes('/packages/tooling/src/index')));

        toolingMods.forEach(m => server.moduleGraph.invalidateModule(m));

        if (toolingMods.length > 0) {
          return toolingMods;
        }
      }
    },

    // Generate on build
    buildStart() {
      registry = generateRegistry();
    },
  };
}

/**
 * Standalone function to generate registry (for MCP server or CLI).
 */
export function generateComponentRegistry(options: IdealystDocsPluginOptions): ComponentRegistry {
  return analyzeComponents(options);
}
